<?php
/**
 * @file
 * google_analytics_counter_queue.module
 */

/**
 * Denotes the core and version number (e.g. 7.x-1.0).
 */
define('GOOGLE_ANALYTICS_COUNTER_QUEUE_VERSION', '7.x-1.0-dev');

/**
 * Denotes the watchdog type.
 */
define('GOOGLE_ANALYTICS_COUNTER_QUEUE_WATCHDOG_TYPE', 'google_analytics_counter_queue');

/**
 * Denotes the HTTP POST method type.
 */
define('GOOGLE_ANALYTICS_COUNTER_QUEUE_HTTP_POST', 'POST');

/**
 * Denotes the HTTP GET method type.
 */
define('GOOGLE_ANALYTICS_COUNTER_QUEUE_HTTP_GET', 'GET');

// Always include the statistics specific code.
require_once 'google_analytics_counter_queue.statistics.inc';

/**
 * Implements hook_menu().
 */
function google_analytics_counter_queue_menu() {
  $items = array();
  $items['admin/config/system/google-analytics-counter-queue'] = array(
    'title' => 'Google Analytics Counter Queue',
    'description' => 'Administer and configure the Google Analytics Counter Queue including authentication and performing batch operations.',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_analytics_counter_queue_admin_settings_form'),
    'file' => 'google_analytics_counter_queue.admin.inc',
  );
  $items['admin/config/system/google-analytics-counter-queue/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );
  $items['admin/config/system/google-analytics-counter-queue/queue'] = array(
    'title' => 'Queue',
    'type' => MENU_LOCAL_TASK,
    'description' => 'Manage the queue of items to be processed.',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_analytics_counter_queue_admin_queue_manage_form'),
    'file' => 'google_analytics_counter_queue.admin.inc',
    'weight' => 3,
  );
  $items['admin/config/system/google-analytics-counter-queue/queue/add'] = array(
    'title' => 'Add queue item',
    'type' => MENU_LOCAL_ACTION,
    'description' => 'Add a new item to the queue.',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_analytics_counter_queue_queue_item_edit'),
  );
  $items['admin/config/system/google-analytics-counter-queue/queue/item/%google_analytics_counter_queue_queue_item/edit'] = array(
    'title' => 'Edit item',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'description' => 'Edit an existing item within the queue.',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'google_analytics_counter_queue_queue_item_edit_page',
    'page arguments' => array(6),
  );
  $items['admin/config/system/google-analytics-counter-queue/queue/item/%google_analytics_counter_queue_queue_item/delete'] = array(
    'title' => 'Delete item',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'description' => 'Delete an existing item within the queue.',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_analytics_counter_queue_queue_item_delete_confirm', 6),
  );
  $items['admin/config/system/google-analytics-counter-queue/authentication'] = array(
    'title' => 'Authentication',
    'type' => MENU_LOCAL_TASK,
    'description' => '',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_analytics_counter_queue_admin_authentication_form'),
    'file' => 'google_analytics_counter_queue.admin.inc',
    'weight' => 2,
  );
  $items['admin/config/system/google-analytics-counter-queue/statistics'] = array(
    'title' => 'Statistics',
    'type' => MENU_LOCAL_TASK,
    'description' => '',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_analytics_counter_queue_admin_statistics'),
    'file' => 'google_analytics_counter_queue.admin.inc',
    'weight' => 3,
  );
  $items['admin/config/system/google-analytics-counter-queue/statistics/%google_analytics_counter_queue_statistic/view'] = array(
    'title' => 'View statistic',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'description' => 'View statistical information for an individual statistic record.',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'google_analytics_counter_queue_statistic_view_page',
    'page arguments' => array(5),
    'file' => 'google_analytics_counter_queue.statistics.inc',
  );
  $items['admin/config/system/google-analytics-counter-queue/statistics/%google_analytics_counter_queue_statistic/delete'] = array(
    'title' => 'Delete statistic',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'description' => 'Delete statistical information for an individual statistic record.',
    'access arguments' => array('administer google analytics counter queue'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_analytics_counter_queue_statistic_delete_confirm', 5),
    'file' => 'google_analytics_counter_queue.statistics.inc',
  );
  $items['google-analytics-counter-queue/oauth'] = array(
    'title' => 'OAuth callback endpoint',
    'type' => MENU_CALLBACK,
    'description' => 'Callback for the OAuth authentication with Google Analytics.',
    'page callback' => 'google_analytics_counter_queue_oauth_callback',
    'access callback' => TRUE,
  );
  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function google_analytics_counter_queue_admin_paths() {
  return array(
    'admin/config/system/google-analytics-counter-queue' => TRUE,
    'admin/config/system/google-analytics-counter-queue/*' => TRUE,
    'admin/config/system/google-analytics-counter-queue/queue/item/add' => TRUE,
    'admin/config/system/google-analytics-counter-queue/queue/item/*/edit' => TRUE,
    'admin/config/system/google-analytics-counter-queue/queue/item/*/delete' => TRUE,
    'admin/config/system/google-analytics-counter-queue/statistics' => TRUE,
    'admin/config/system/google-analytics-counter-queue/statistics/*/edit' => TRUE,
    'admin/config/system/google-analytics-counter-queue/statistics/*/delete' => TRUE,
  );
}

/**
 * Implements hook_permission().
 */
function google_analytics_counter_queue_permission() {
  return array(
    'administer google analytics counter queue' => array(
      'title' => 'Administer Google Analytics Counter Queue',
    ),
  );
}

/**
 * Implements hook_theme().
 */
function google_analytics_counter_queue_theme() {
  return array(
    'google_analytics_counter_queue_google_analytics_profile_label' => array(
      'arguments' => array('profile' => NULL),
      'file' => 'google_analytics_counter_queue.theme.inc',
    ),
    'google_analytics_counter_queue_tableselectdrag' => array(
      'render element' => 'element',
      'file' => 'google_analytics_counter_queue.theme.inc',
    ),
  );
}

/**
 * Implements hook_element_info().
 */
function google_analytics_counter_queue_element_info() {
  $types = array();
  $types['google_analytics_counter_queue_tableselectdrag'] = array(
    '#input' => TRUE,
    '#js_select' => TRUE,
    '#multiple' => TRUE,
    '#process' => array('google_analytics_counter_queue_form_process_tableselectdrag'),
    '#rows' => array(),
    '#empty' => '',
    '#theme' => 'google_analytics_counter_queue_tableselectdrag',
  );
  return $types;
}

/**
 * Implements hook_cron().
 */
function google_analytics_counter_queue_cron() {
  if (google_analytics_counter_queue_execute_chunk_processing_on_cron()) {
    google_analytics_counter_queue_process_chunks();
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function google_analytics_counter_queue_cron_queue_info() {
  $queues = array();
  $skip_on_cron = !((bool) google_analytics_counter_queue_execute_queues_on_cron());
  $queues['google_analytics_counter_queue_queue'] = array(
    'worker callback' => 'google_analytics_counter_queue_process_queue',
    'time' => 120,
    'skip on cron' => $skip_on_cron,
  );
  return $queues;
}

/**
 * Includes all modules which implement the API via Ctools.
 */
function google_analytics_counter_queue_module_include() {
  ctools_include('plugins');
  ctools_plugin_api_include('google_analytics_counter_queue',
    'google_analytics_counter_queue',
    google_analytics_counter_queue_api_version(),
    google_analytics_counter_queue_api_version()
  );
}

/**
 * Returns the current API version.
 *
 * @return string
 */
function google_analytics_counter_queue_api_version() {
  return '1.0';
}

/**
 * Implements hook_ctools_plugin_api_hook_name().
 */
function google_analytics_counter_queue_ctools_plugin_api_hook_name() {
  return 'google_analytics_counter_queue_api';
}

/**
 * Implements hook_google_analytics_counter_queue_api().
 */
function google_analytics_counter_queue_google_analytics_counter_queue_api() {
  return array(
    'api' => google_analytics_counter_queue_api_version(),
    'path' => drupal_get_path('module', 'google_analytics_counter_queue') . '/modules',
  );
}

/**
 * Wrapper for `watchdog`.
 *
 * @param int $severity
 *   The severity level.
 * @param string $message
 *   The message to log.
 * @param array $variables
 *   Any variables related to the message for translation.
 */
function google_analytics_counter_queue_log($severity, $message, $variables = array()) {
  watchdog(GOOGLE_ANALYTICS_COUNTER_QUEUE_WATCHDOG_TYPE, $message, $variables, $severity);
}

/**
 * Wrapper for the `watchdog_exception`.
 *
 * @param Exception $exception
 *   The exception to log.
 */
function google_analytics_counter_queue_log_exception(Exception $exception) {
  watchdog_exception(GOOGLE_ANALYTICS_COUNTER_QUEUE_WATCHDOG_TYPE, $exception);
}

/**
 * Returns a boolean indicating whether the queue should be processed on cron.
 *
 * @return boolean
 *   Returns TRUE if the queue should be processed during cron, otherwise FALSE.
 */
function google_analytics_counter_queue_execute_queues_on_cron() {
  return variable_get('google_analytics_counter_queue_execute_queues_on_cron', TRUE);
}

/**
 * @return boolean
 */
function google_analytics_counter_queue_execute_chunk_processing_on_cron() {
  return variable_get('google_analytics_counter_queue_execute_chunk_processing_on_cron', TRUE);
}

/**
 * Queue worker for processing individual queue items.
 *
 * @param mixed $queue_item
 *   The queue item that is to be processed. An array of queue items can be
 *   specified to process one or more items in a single API request.
 */
function google_analytics_counter_queue_process_queue($queue_item) {
  // TODO: Document and clean up code.
  $queue_items = is_array($queue_item) ? $queue_item : array($queue_item);

  if (empty($queue_items)) {
    return FALSE;
  }

  // Retrieve the API client instance.
  $client = google_analytics_counter_queue_api_client();

  $total_records = NULL;
  $remaining_records = NULL;
  $pathview_info = array();
  $error = FALSE;
  $start_index = 0;

  $profile_id = google_analytics_counter_queue_api_profile_id();

  $dimensions = array('ga:pagePath');
  $metrics = array('ga:pageviews');

  $filters = array();

  foreach ($queue_items as $queue_item) {
    $filters['ga:pagePath'][] = array(
      'value' => $queue_item->getPath(),
      'operator' => '=@',
    );
  }

  $aggregate_info = array();

  $total_records = 0;
  do {
    if ($total_records && $remaining_records) {
      $diff_records_count = $total_records - $remaining_records;
      if (0 > $diff_records_count) {
        $error = TRUE;
        break;
      }
      elseif (0 < $diff_records_count) {
        $multiplier = round($diff_records_count / google_analytics_counter_queue_api_data_query_max_results(), 0);
        $start_index = google_analytics_counter_queue_api_data_query_max_results() * $multiplier;
        $start_index++;
      }
    }

    if ($error) {
      break;
    }

    $response = google_analytics_counter_queue_api_request_data($client, $profile_id, $dimensions, $metrics, $filters, NULL, NULL, $start_index, NULL);
    if (!$response) {
      $error = TRUE;
      break;
    }

    if ($total_records != $response['data']['totalResults']) {
      $total_records = $response['data']['totalResults'];
    }

    if (0 < $total_records) {
      if (isset($start_index)) {
        $max_records = $start_index + $response['data']['itemsPerPage'];
        if ($max_records >= $total_records) {
          $remaining_records = 0;
        }
        else {
          $remaining_records = $total_records - $max_records;
        }
      }
      elseif ($response['data']['itemsPerPage'] < $total_records) {
        $remaining_records = $total_records - $response['data']['itemsPerPage'];
      }
      elseif ($total_records < $response['data']['itemsPerPage']) {
        $remaining_records = 0;
      }

      _google_analytics_counter_queue_api_request_data_process_aggregate($response['data']['rows'], $aggregate_info);
    }
    else {
      $error = TRUE;
    }
  }
  while (!$error && ($remaining_records > 0 || NULL === $remaining_records));

  if (!$error && !empty($aggregate_info)) {
    foreach ($queue_items as $k => &$queue_item) {
      $source_path = drupal_get_normal_path($queue_item->getPath());
      if (isset($aggregate_info[$source_path])) {
        $statistics = _google_analytics_counter_queue_process_statistics($source_path, $aggregate_info[$source_path]);
        // Set processed state to TRUE, allowing for the queue item deletion.
        $queue_item->setProcessedState(TRUE);
        // Load all modules which make use of the API definition.
        google_analytics_counter_queue_module_include();
        // This module hook invocation is potentially problematic because of
        // the potential to have large number of source paths to process. Should
        // the implementer perform extensive operations, this could result in
        // degradation of performance.
        module_invoke_all('google_analytics_counter_queue_statistics_processed', $statistics, $source_path);
      }
    }
  }
}

/**
 *
 */
function google_analytics_counter_queue_process_chunks() {
  $client = google_analytics_counter_queue_api_client();
  $profile_id = google_analytics_counter_queue_api_profile_id();
  $start_index = google_analytics_counter_queue_chunk_process_start_index();
  if ($response = google_analytics_counter_queue_api_request_data($client, $profile_id, array('ga:pagePath'), array('ga:pageviews'), array(), NULL, NULL, $start_index, NULL)) {
    if (empty($response['data']['rows'])) {
      variable_set('google_analytics_counter_queue_chunk_process_start_index', 0);
      return;
    }

    $aggregate_info = array();
    _google_analytics_counter_queue_api_request_data_process_aggregate($response['data']['rows'], $aggregate_info);
    // If actual data is returned and the aggregate information is populated,
    // process the statistics for each source path.
    if (!empty($aggregate_info)) {
      foreach ($aggregate_info as $source_path => &$view_info) {
        $statistics = _google_analytics_counter_queue_process_statistics($source_path, $view_info);
        // Load all modules which make use of the API definition.
        google_analytics_counter_queue_module_include();
        // This module hook invocation is potentially problematic because of
        // the potential to have large number of source paths to process. Should
        // the implementer perform extensive operations, this could result in
        // degradation of performance.
        module_invoke_all('google_analytics_counter_queue_statistics_processed', $statistics, $source_path);
      }
    }
    variable_set('google_analytics_counter_queue_chunk_process_start_index', $start_index + count($response['data']['rows']));
  }
}

/**
 * Returns the chunk processing start index value.
 *
 * @return int
 *   The start index used for the next data chunk request.
 */
function google_analytics_counter_queue_chunk_process_start_index() {
  return (int) variable_get('google_analytics_counter_queue_chunk_process_start_index', 0);
}

/**
 * Resets the chunk processing start index value.
 */
function google_analytics_counter_queue_chunk_process_start_index_reset() {
  variable_set('google_analytics_counter_queue_chunk_process_start_index', 0);
}

/**
 * @param array $data
 * @param array $aggregate
 */
function _google_analytics_counter_queue_api_request_data_process_aggregate(array $data, array &$aggregate) {
  foreach ($data as $row) {
    list($path, $view_count) = $row;
    $pathinfo = parse_url($path);
    if (!empty($pathinfo['path'])) {
      $pathinfo['path'] = ltrim(strtolower($pathinfo['path']), '/');
      if (isset($aggregate[$pathinfo['path']]) && FALSE === $aggregate[$pathinfo['path']]) {
        continue;
      }
      // Only if the parsed path information has a valid path will we actually
      // process and append to the aggregate data set.
      if (google_analytics_counter_queue_valid_path($pathinfo['path'])) {
        $source_path = drupal_get_normal_path($pathinfo['path']);
        // Check and verify that we are or are not processing administrative
        // paths. If we are not, skip this path from populating the aggregate if
        // it is a valid admin path.
        if (!google_analytics_counter_queue_queue_process_admin_paths() && path_is_admin($source_path)) {
          continue;
        }
        // Skip any ignored paths should this path match one of the ignored path
        // patterns that has been configured.
        $ignored_paths = google_analytics_counter_queue_queue_ignored_paths();
        if (!empty($ignored_paths) && drupal_match_path($pathinfo['path'], $ignored_paths)) {
          continue;
        }
        // Initialize the aggregate information should the source path does not
        // exist yet within the aggregate array.
        if (!isset($aggregate[$source_path])) {
          $aggregate[$source_path] = array();
        }
        if (!isset($aggregate[$source_path][$pathinfo['path']])) {
          $aggregate[$source_path][$pathinfo['path']] = 0;
        }
        $aggregate[$source_path][$pathinfo['path']] += (int) $view_count;
      }
    }
  }
}

/**
 * Processes the aggregate view count data for the specified source path.
 *
 * @param string $source_path
 *   The source path of the aggregate data.
 * @param array $view_info
 *   An array of alias paths and the path's view count.
 *
 * @returns mixed
 *   Returns the statistical object if the aggregate view information has been
 *   successfully processed. Otherwise will return FALSE on error.
 */
function _google_analytics_counter_queue_process_statistics($source_path, array &$view_info) {
  // If the specified aggregate view information for the $source_path is empty,
  // exit early as there is nothing for us to do.
  if (empty($view_info)) {
    return FALSE;
  }
  // Retrieve the existing statistical information for the source path. If it
  // does not exist, attempt to initialize and create a new statistical record.
  module_load_include('inc', 'google_analytics_counter_queue', 'google_analytics_counter_queue.statistics');
  $statistics = google_analytics_counter_queue_statistics_path($source_path);
  if (!$statistics) {
    $statistics = google_analytics_counter_queue_statistics_create($source_path, 0, time());
    if (FALSE === $statistics) {
      google_analytics_counter_queue_log(WATCHDOG_NOTICE, 'Unable to load or generate statistics information for path: @path.', array(
        '@path' => $source_path,
      ));
      return FALSE;
    }
  }
  // Process the view count information for each of the aliased paths that
  // relate to the source path.
  foreach ($view_info as $path => $view_count) {
    // If the view count is FALSE, skip, then move on.
    if (FALSE === $view_count) {
      continue;
    }

    try {
      // We use the time() function below instead of REQUEST_TIME due to the
      // fact that this function is generally called within a long running
      // process and time() is more accurate in this case.
      if (isset($statistics->items[$path])) {
        db_update('google_analytics_counter_queue_statistics_path')
          ->fields(array(
            'updated' => time(),
            'count' => $view_count,
          ))
          ->condition('id', $statistics->items[$path]->id)
          ->execute();
        $statistics->items[$path]->count = $view_count;
      } else {
        $fields = array(
          'created' => time(),
          'updated' => time(),
          'path' => $path,
          'count' => $view_count,
          'statistic_id' => $statistics->statistic_id,
        );

        $id = db_insert('google_analytics_counter_queue_statistics_path')
          ->fields($fields)
          ->execute();
        $fields['id'] = $id;
        $statistics->items[$path] = (object)$fields;
      }
    }
    catch (Exception $e) {
      google_analytics_counter_queue_log_exception($e);
    }
  }
  // We perform a query to retrieve the sum as it calculating at runtime
  // with the above processing might not always be successful due to
  // additional path specific statistic information existing that was not
  // processed above.
  $query = db_select('google_analytics_counter_queue_statistics_path', 'p')
    ->condition('p.statistic_id', $statistics->statistic_id);
  $query->addExpression('SUM(p.count)', 'sum');
  $sum = $query->execute()
    ->fetchObject();
  // Assuming the sum calculation was successful and the current total
  // number of views is not the same, we will update the aggregated
  // total number of views.
  if (FALSE !== $sum && $sum->sum != $statistics->totalcount) {
    $timestamp = time();
    db_update('google_analytics_counter_queue_statistics')
      ->fields(array(
        'totalcount' => $sum->sum,
        'updated' => $timestamp,
      ))
      ->condition('statistic_id', $statistics->statistic_id)
      ->execute();
    // Update the static cache of the statistical information objects.
    $statistics->updated = $timestamp;
    $statistics->totalcount = $sum->sum;
    $statistic_info = &drupal_static('google_analytics_counter_queue_statistics_path', array());
    $statistic_info[$statistics->path] = $statistics;
  }
  return $statistics;
}

/**
 * Retrieves the Google Analytics Counter Queue queue instance.
 *
 * @return GoogleAnalyticsCounterQueueQueue
 *   The queue instance.
 */
function google_analytics_counter_queue_queue() {
  return DrupalQueue::get('google_analytics_counter_queue_queue');
}

/**
 * Load callback handler for loading a single Queue item from the queue.
 *
 * @param int $item_id
 *   The queue item's item_id value (item identifier).
 *
 * @return mixed
 *   Returns the queue item if it exists, otherwise returns NULL.
 */
function google_analytics_counter_queue_queue_item_load($item_id) {
  // TODO: Optimize this implementation.
  $query = db_select('google_analytics_counter_queue_queue', 'q')
    ->fields('q')
    ->condition('item_id', $item_id)
    ->execute();
  if ($record = $query->fetchObject()) {
    return GoogleAnalyticsCounterQueueQueueItem::factory($record);
  }
  return FALSE;
}

/**
 * Loads a single queue item given a path.
 *
 * @param string $path
 *   The path of the queue item to load.
 *
 * @return mixed
 *   Returns the queue item if it exists, otherwise returns NULL.
 */
function google_analytics_counter_queue_queue_item_load_by_path($path) {
  // TODO: Optimize this implementation.
  $query = db_select('google_analytics_counter_queue_queue', 'q')
    ->fields('q')
    ->condition('path', $path)
    ->execute();
  if ($record = $query->fetchObject()) {
    return GoogleAnalyticsCounterQueueQueueItem::factory($record);
  }
  return FALSE;
}

/**
 * Adds the administrative ui css if not already added to the page.
 */
function google_analytics_counter_queue_add_admin_css() {
  static $admin_css_added = FALSE;
  if (!$admin_css_added) {
    drupal_add_css(drupal_get_path('module', 'google_analytics_counter_queue') . '/misc/google_analytics_counter_queue.admin.css', array('group' => CSS_DEFAULT));
    $admin_css_added = TRUE;
  }
}

/**
 * Verbatim of form_process_tableselect in Drupal core.
 *
 * However, this implementation resolves the issue where the
 * `$element['#attributes']` value is assigned to the checkbox or the radio
 * button's `#attribute` property.
 *
 * @param array $element
 *   An associative array containing the properties and children of the element.
 *
 * @return array
 *   The processed element.
 */
function google_analytics_counter_queue_form_process_tableselectdrag($element) {
  static $element_ids = array();

  $element['#tree'] = TRUE;
  $element['#tableselectdrag_settings'] += array(
    'action' => '',
    'relationship' => '',
    'group' => '',
    'subgroup' => NULL,
    'source' => '',
    'hidden' => TRUE,
    'limit' => 0,
  );

  if (empty($element['#attributes']['id'])) {
    // Automatically generate a identifier for the table element; this will
    // provide us the ability to ensure that the tableDrag functionality has
    // a specified target at all times.
    $element['#attributes']['id'] = 'tableselectdrag-' . count($element_ids);
  }

  $element_ids[] = $element['#attributes']['id'];

  if ($element['#multiple']) {
    $value = is_array($element['#value']) ? $element['#value'] : array();
  }
  else {
    $element['#js_select'] = FALSE;
  }

  if (0 < count($element['#rows'])) {
    if (!isset($element['#default_value']) || 0 === $element['#default_value']) {
      $element['#default_value'] = array();
    }

    $element['#header'] = array('select' => '') + $element['#header'];

    foreach ($element['#rows'] as $key => $choice) {
      if (!isset($element[$key])) {
        if ($element['#multiple']) {
          $title = '';
          if (!empty($element['#rows'][$key]['title']['data']['#title'])) {
            $title = t('Update @title', array(
              '@title' => $element['#options'][$key]['title']['data']['#title'],
            ));
          }

          $select_field = array(
            '#type' => 'checkbox',
            '#title' => $title,
            '#title_display' => 'invisible',
            '#return_value' => $key,
            '#default_value' => isset($value[$key]) ? $key : NULL,
          );
        }
        else {
          $parents_for_id = array_merge($element['#parents'], array($key));
          $select_field = array(
            '#type' => 'radio',
            '#title' => '',
            '#return_value' => $key,
            '#default_value' => $key == $element['#default_value'] ? $key : NULL,
            '#parents' => $element['#parents'],
            '#id' => drupal_html_id('edit-' . implode('-', $parents_for_id)),
            '#ajax' => isset($element['#ajax']) ? $element['#ajax'] : NULL,
          );
        }

        $element['#rows'][$key] = array(
          'select' => array('data' => $select_field)
        ) + $element['#rows'][$key];

        if (isset($element['#rows'][$key]['#weight'])) {
          $element[$key]['#weight'] = $element['#rows'][$key]['#weight'];
        }
      }
    }
  }
  else {
    $element['#value'] = array();
  }

  return $element;
}

/**
 * Retrieves the next weight value within a queue based on a position.
 *
 * When trying to retrieve a weight value so that the weight would be used to
 * place a queue item at the top of a queue, $position should be specified as
 * `top`, where as the default is `bottom`.
 *
 * @param string $position
 *   The location in which to retrieve the next weight value for. Valid options
 *   are either `top` or `bottom`. Default is `bottom`.
 *
 * @return mixed
 *   Returns the weight value
 */
function google_analytics_counter_queue_queue_item_next_weight($position = 'bottom') {
  $weight = FALSE;
  $query = db_select('google_analytics_counter_queue_queue', 'q')
    ->fields('q', array('weight'))
    ->range(0, 1);
  switch ($position) {
    case 'top':
      $query->orderBy('q.weight', 'ASC');
      $value = -1;
      break;
    case 'bottom':
    default:
      $query->orderBy('q.weight', 'DESC');
      $value = 1;
      break;
  }
  $result = $query->execute()->fetchField();
  $weight = $result + $value;
  return $weight;
}

/**
 * Returns Google Analytics API start-date query parameter value.
 *
 * @return string
 *   The query start date in YYYY-MM-DD format.
 */
function google_analytics_counter_queue_api_data_query_start_date() {
  // Google Analytics API requires that the `start-date` of any query is greater
  // than or equal to that of January 1st, 2005 (2005-01-01).
  return variable_get('google_analytics_counter_queue_google_analytics_data_query_start_date', '2005-01-01');
}

/**
 * Returns the GoogleAnalyticsCounterQueueGoogleApiClient instance.
 *
 * The client is cached statically upon instantiation and therefore, additional
 * instances cannot be created by invoking this function and need to be created
 * using the `new Google...` syntax.
 *
 * @return GoogleAnalyticsCounterQueueGoogleApiClient
 *   The client instance using the stored oauth consumer and access tokens.
 */
function google_analytics_counter_queue_api_client() {
  static $static_fast_cache = NULL;
  if (NULL === $static_fast_cache) {
    $static_fast_cache = new GoogleAnalyticsCounterQueueGoogleApiClient(
      google_analytics_counter_queue_api_oauth_consumer(),
      google_analytics_counter_queue_api_oauth_token()
    );
  }
  return $static_fast_cache;
}

/**
 * Returns the Google API OAuth consumer key.
 *
 * @return string
 *   The consumer key stored, otherwise returns `anonymous`.
 */
function google_analytics_counter_queue_api_oauth_consumer_key() {
  return variable_get('google_analytics_counter_queue_api_oauth_consumer_key', 'anonymous');
}

/**
 * Returns the Google API OAuth consumer secret.
 *
 * @return string
 *   The consumer secret stored, otherwise returns `anonymous`.
 */
function google_analytics_counter_queue_api_oauth_consumer_secret() {
  return variable_get('google_analytics_counter_queue_api_oauth_consumer_secret', 'anonymous');
}

/**
 * Returns the Google API OAuth consumer object.
 *
 * @param bool $reset
 *   A boolean indicating whether or not the static cached consumer token should
 *   be reset using the values from consumer token variables.
 *
 * @return GoogleAnalyticsCounterQueueOAuthToken
 *   The consumer token (key and secret) object instance.
 */
function google_analytics_counter_queue_api_oauth_consumer($reset = FALSE) {
  $static_fast_cache = &drupal_static('google_analytics_counter_queue_api_oauth_consumer', NULL);
  if (!$static_fast_cache || $reset) {
    $static_fast_cache = new GoogleAnalyticsCounterQueueOAuthToken(
      google_analytics_counter_queue_api_oauth_consumer_key(),
      google_analytics_counter_queue_api_oauth_consumer_secret()
    );
  }
  return $static_fast_cache;
}

/**
 * Returns the Google API OAuth access token key.
 *
 * @return string
 *   Returns the access token key stored, otherwise NULL.
 */
function google_analytics_counter_queue_api_oauth_token_key() {
  return variable_get('google_analytics_counter_queue_api_oauth_token', NULL);
}

/**
 * Returns the Google API OAuth access token secret.
 *
 * @return string
 *   Returns the access token secret stored, otherwise NULL.
 */
function google_analytics_counter_queue_api_oauth_token_secret() {
  return variable_get('google_analytics_counter_queue_api_oauth_token_secret', NULL);
}

/**
 * Returns the Google API OAuth access token object.
 *
 * @param bool $reset
 *   A boolean indicating whether or not the static cached token should be
 *   reset using the values from oauth token variables.
 *
 * @return GoogleAnalyticsCounterQueueOAuthToken
 *   The access token (key and secret) object instance if they are set;
 *   otherwise will return NULL.
 */
function google_analytics_counter_queue_api_oauth_token($reset = FALSE) {
  $static_fast_cache = &drupal_static('google_analytics_counter_queue_api_oauth_token', NULL);
  if (!$static_fast_cache || $reset) {
    $oauth_token_key = google_analytics_counter_queue_api_oauth_token_key();
    $oauth_token_secret = google_analytics_counter_queue_api_oauth_token_secret();
    if (!empty($oauth_token_key) && !empty($oauth_token_secret) && 'anonymous' != $oauth_token_key && 'anonymous' != $oauth_token_secret) {
      $static_fast_cache = new GoogleAnalyticsCounterQueueOAuthToken($oauth_token_key, $oauth_token_secret);
    }
    else {
      return NULL;
    }
  }
  return $static_fast_cache;
}

/**
 * Returns the Google Analytics Profile ID in which processing should occur on.
 *
 * @return mixed
 *   The Google Analytics profile id.
 */
function google_analytics_counter_queue_api_profile_id() {
  return variable_get('google_analytics_counter_queue_api_profile_id', NULL);
}

/**
 * Returns the OAuth Callback URL as an absolute URL.
 *
 * @return string
 *   The URL.
 */
function google_analytics_counter_queue_oauth_callback_url() {
  return url('google-analytics-counter-queue/oauth', array('absolute' => TRUE));
}

/**
 * Returns the display name for the xoauth_display_name parameters.
 *
 * @return string
 *   The display name.
 */
function google_analytics_counter_queue_xoauth_display_name() {
  $display_name = t('Google Analytics Counter Queue - Drupal module');
  // Allow other modules to change the display name which is displayed on
  // the Google accounts authorization form. This will allow sites to uniquely
  // identify which application is being connected.
  drupal_alter('google_analytics_counter_queue_xoauth_display_name', $display_name);
  return $display_name;
}

/**
 * Page callback for the Google API's OAuth authentication.
 */
function google_analytics_counter_queue_oauth_callback() {
  $consumer_token = google_analytics_counter_queue_api_oauth_consumer();
  // The OAuth request token will exist and be stored within the user's session
  // upon initial authentication. Retrieve it and then remove the data from
  // the session so that additional requests will not effectively work.
  if (isset($_SESSION['google_analytics_counter_queue'])) {
    $session_data = $_SESSION['google_analytics_counter_queue'];
    unset($_SESSION['google_analytics_counter_queue']);
  }
  else {
    return drupal_access_denied();
  }

  $parameters = drupal_get_query_parameters(NULL);
  $oauth_token = isset($parameters['oauth_token']) ? $parameters['oauth_token'] : '';
  $oauth_verifier = isset($parameters['oauth_verifier']) ? $parameters['oauth_verifier'] : '';
  // The Google API will send back the OAuth Token and Verifier via GET params,
  // therefore verify that they exist; should they not - exit.
  if (!$oauth_token || !$oauth_verifier || empty($session_data['oauth']['token'])) {
    return drupal_access_denied();
  }
  // Ensure that a user is not trying to "fake" the OAuth Token via the query
  // parameters. Verify that the previously retrieved request key is equal
  // to that of the query string parameter.
  if ($session_data['oauth']['token']->key != $oauth_token) {
    return drupal_access_denied();
  }
  // Create a new instance of the API Client class using the consumer token
  // and the request token previously received via authentication.
  $client = new GoogleAnalyticsCounterQueueGoogleApiClient($consumer_token, $session_data['oauth']['token']);
  $client->setVerifier($oauth_verifier);
  // Retrieve the access token.
  $access_token = $client->getAccessToken();
  // Set the access token key and secret so that it can be used later.
  variable_set('google_analytics_counter_queue_api_oauth_token', $access_token->key);
  variable_set('google_analytics_counter_queue_api_oauth_token_secret', $access_token->secret);
  // Redirect the user to the admin's authentication form for the module.
  drupal_goto('admin/config/system/google-analytics-counter-queue/authentication');
}

/**
 * Checks if the specified $path exists within the Queue.
 *
 * @param string $path
 *   The path to test if it exists.
 *
 * @return bool
 *   Returns TRUE if the path already exists within the queue, otherwise FALSE.
 */
function google_analytics_counter_queue_queue_exists_with_path($path) {
  $static_fast_cache = &drupal_static(__FUNCTION__, array());
  if (!isset($static_fast_cache[$path])) {
    $query = db_select('google_analytics_counter_queue_queue', 'q')
      ->fields('q', array('item_id'))
      ->condition('q.path', $path)
      ->execute();
    if ($result = $query->fetchField()) {
      $static_fast_cache[$path] = TRUE;
    }
    else {
      $static_fast_cache[$path] = FALSE;
    }
  }

  return $static_fast_cache[$path];
}

/**
 * Queue item editing page; renders edit form.
 *
 * @param GoogleAnalyticsCounterQueueQueueItem $item
 *   The queue item being edited.
 *
 * @return array
 *   The `google_analytics_counter_queue_queue_item_edit` form.
 */
function google_analytics_counter_queue_queue_item_edit_page($item) {
  drupal_set_title(t('<em>Edit queue item</em> @title', array('@title' => $item->getData()->path)), PASS_THROUGH);
  return drupal_get_form('google_analytics_counter_queue_queue_item_edit', $item);
}

/**
 * Queue item form builder for create and edit forms.
 *
 * @param array $form
 *   An array of form elements and properties.
 * @param array $form_state
 *   An array representing the current form's state.
 * @param GoogleAnalyticsCounterQueueQueueItem $queue_item
 *   The queue item which is being edited.
 *
 * @return array
 *   The create and edit form array.
 */
function google_analytics_counter_queue_queue_item_edit($form, &$form_state, GoogleAnalyticsCounterQueueQueueItem $queue_item = NULL) {
  $form['#queue_item'] = $queue_item;
  $form['item'] = array(
    '#type' => 'fieldset',
    '#title' => t('Item information'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
  $form['item']['path'] = array(
    '#type' => 'textfield',
    '#title' => t('Path'),
    '#description' => t('Specify a Drupal path (system or alias) which will be added to the queue for processing.'),
    '#default_value' => $queue_item ? $queue_item->getPath() : '',
    '#required' => TRUE,
  );

  if (empty($queue_item)) {
    $form['item']['position'] = array(
      '#type' => 'select',
      '#title' => t('Position options'),
      '#options' => google_analytics_counter_queue_queue_item_form_position_options(),
      '#default_value' => 'bottom',
      '#required' => TRUE,
    );
  }

  $form['item']['item_id'] = array(
    '#type' => 'value',
    '#value' => !empty($queue_item) ? $queue_item->getIdentifier() : NULL,
  );
  $form['item']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );

  $form['destination'] = array(
    '#type' => 'value',
    '#value' => 'admin/config/system/google-analytics-counter-queue/queue',
  );
  return $form;
}

/**
 * Queue item form validation handler for creating or editing an item.
 *
 * @param array $form
 *   An array of form elements and properties.
 * @param array $form_state
 *   An array representing the current form's state.
 */
function google_analytics_counter_queue_queue_item_edit_validate($form, &$form_state) {
  $queue_item = $form['#queue_item'];
  if ((!empty($queue_item) && $queue_item->getPath() != $form_state['values']['path']) || empty($queue_item)) {
    if (google_analytics_counter_queue_valid_path($form_state['values']['path'])) {
      if (google_analytics_counter_queue_queue_exists_with_path($form_state['values']['path'])) {
        form_set_error('path', t('The specified path (%path) already exists within the queue.', array(
          '%path' => $form_state['values']['path'],
        )));
      }
    }
    else {
      form_set_error('path', t('The specified path does not appear to exist and or is not valid.'));
    }
  }
}

/**
 * Queue item form submit handler for creating or editing an item.
 *
 * @param array $form
 *   An array of form elements and properties.
 * @param array $form_state
 *   An array representing the current form's state.
 */
function google_analytics_counter_queue_queue_item_edit_submit($form, &$form_state) {
  $queue_item = $form['#queue_item'];
  if (empty($queue_item)) {
    $queue_item = new GoogleAnalyticsCounterQueueQueueItem();
    $queue_item->setCreated(REQUEST_TIME);
  }

  $queue_item->setPath($form_state['values']['path']);
  if (isset($form_state['values']['position'])) {
    $position = $form_state['values']['position'];
    if (FALSE !== ($weight = google_analytics_counter_queue_queue_item_next_weight($position))) {
      $queue_item->setWeight($weight);
    }
  }

  if ($queue_item->save()) {
    drupal_set_message(t('You have successfully saved queue item %item_id (%path).', array(
      '%item_id' => $queue_item->getIdentifier(),
      '%path' => $queue_item->getPath(),
    )));
  }

  if (!empty($form_state['values']['destination'])) {
    $form_state['redirect'] = array($form_state['values']['destination']);
  }
  else {
    $form_state['redirect'] = array('admin/config/system/google-analytics-counter-queue');
  }
}

/**
 * Queue item delete confirmation form.
 *
 * @param array $form
 *   An array of form elements and properties.
 * @param array $form_state
 *   An array representing the current form's state.
 * @param GoogleAnalyticsCounterQueueQueueItem $queue_item
 *   The queue item to be deleted.
 *
 * @return array
 *   Returns the form array to render.
 */
function google_analytics_counter_queue_queue_item_delete_confirm($form, &$form_state, $queue_item) {
  $form['item_id'] = array(
    '#type' => 'value',
    '#value' => $queue_item->getIdentifier(),
  );
  return confirm_form($form, t('Are you sure you want to delete queue item %item_id (%path)?', array('%item_id' => $queue_item->getIdentifier(), '%path' => $queue_item->getPath())), 'admin/config/system/google-analytics-counter-queue', t('This action cannot be undone.'), t('Delete'), t('Cancel'));
}

/**
 * Queue item delete confirmation form submit handler.
 *
 * @param array $form
 *   An array of form elements and properties.
 * @param array $form_state
 *   An array representing the current form's state.
 */
function google_analytics_counter_queue_queue_item_delete_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    $queue_item = google_analytics_counter_queue_queue_item_load($form_state['values']['item_id']);
    $queue_item->delete();
    drupal_set_message(t('You have successfully deleted queue item %item_id (%path).', array(
      '%item_id' => $queue_item->getIdentifier(),
      '%path' => $queue_item->getPath(),
    )));
    drupal_goto('admin/config/system/google-analytics-counter-queue');
  }
}

/**
 * Returns the maximum number of results to retrieve at once via API requests.
 *
 * @return int
 *   The maximum number of results.
 */
function google_analytics_counter_queue_api_data_query_max_results() {
  return variable_get('google_analytics_counter_queue_api_data_query_max_results', '1000');
}

/**
 * Returns a boolean indicating whether admin paths should be processed.
 *
 * @return bool
 *   Returns TRUE if admin paths are processed via queue, otherwise FALSE.
 */
function google_analytics_counter_queue_queue_process_admin_paths() {
  return (bool) variable_get('google_analytics_counter_queue_queue_process_admin_paths', 0);
}

/**
 * Returns a string representing the paths to ignore during processing.
 *
 * @return string
 *   The paths to ignore. Each unique path on its own line.
 */
function google_analytics_counter_queue_queue_ignored_paths() {
  return variable_get('google_analytics_counter_queue_queue_ignored_paths', '');
}

/**
 * Returns a boolean representing if the statistics node counter is used.
 *
 * @return bool
 *   Returns TRUE if statistics node count is used, otherwise FALSE.
 */
function google_analytics_counter_queue_update_statistics_node_counter() {
  return (bool) variable_get('google_analytics_counter_queue_update_statistics_node_counter', 1);
}

/**
 * Returns a boolean representing if the statistics module allows updates.
 *
 * @return bool
 *   Returns TRUE if the statistics module is setup and configured for best
 *   uses with the Google Analytics Counter Queue and is readied for third party
 *   module updates, otherwise returns FALSE.
 */
function google_analytics_counter_queue_statistics_allow_update() {
  return google_analytics_counter_queue_update_statistics_node_counter() && !variable_get('statistics_count_content_views');
}

/**
 * Returns the processing attempt threshold.
 *
 * @return int
 *   Returns an integer representing the number of attempts to perform the
 *   processing of a single queue item prior to moving onto the next.
 */
function google_analytics_counter_queue_google_analytics_queue_item_threshold() {
  return variable_get('google_analytics_counter_queue_google_analytics_queue_item_threshold', '3');
}

/**
 * Returns an integer representing the number of items to process at once.
 *
 * @return int
 *   The number of items to process at once when the queue is being processed
 *   via the module's custom queue run implementation. Default value is 1.
 */
function google_analytics_counter_queue_queue_process_multiple() {
  return variable_get('google_analytics_counter_queue_queue_process_multiple', 1);
}

/**
 * Returns an integer representing the HTTP request timeout value in seconds.
 *
 * @return int
 *   The number of seconds prior to timing out an HTTP request. Default 30.
 */
function google_analytics_counter_queue_api_http_request_timeout() {
  return (int) variable_get('google_analytics_counter_queue_api_http_request_timeout', 30);
}

/**
 * Generates batch information for a specified array of queue item identifiers.
 *
 * @param array $queue_item_ids
 *   An array of queue item identifiers to generate a batch for.
 *
 * @return array
 *   The batch information.
 */
function google_analytics_counter_queue_process_queue_batch(array $queue_item_ids) {
  $operations = array();
  foreach ($queue_item_ids as $queue_item_id) {
    $operations[] = array(
      'google_analytics_counter_queue_process_queue_batch_op',
      array($queue_item_id),
    );
  }
  $batch = array(
    'operations' => $operations,
    'title' => t('Processing queue items'),
    'init_message' => t('Initializing batch for processing queue items'),
    'progress_message' => t('Processed @current out of @total'),
    'error_message' => t('Batch processing has encountered an error.'),
  );
  return $batch;
}

/**
 * Queue item batch operation callback. Processes a single queue item.
 *
 * @param int $item_id
 *   The id of the queue item to process.
 * @param array $context
 *   The batch context information array.
 *
 * @return bool
 *   Always returns TRUE.
 */
function google_analytics_counter_queue_process_queue_batch_op($item_id, &$context) {
  if (empty($context['sandbox'])) {
    $context['sandbox'] = array();
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_queue_item'] = $item_id;
  }

  // Attempt to load the queue item and set the lease expiring.
  $queue_item = google_analytics_counter_queue_queue_item_load($item_id);
  $queue_item->setExpires(time() + 3600);
  $queue_item->save();

  do {
    $processed = FALSE;
    // Attempt to process the queue item for the first time (always). However,
    // should the queue item not be able to be fully processed or unable to be
    // processed at all (e.g. HTTP timeout), let's just try again.
    google_analytics_counter_queue_process_queue($queue_item);
    // Has the queue item been processed and the processed state set?
    /* if (!$queue_item->getProcessedState() &&
          (0 === $queue_item->getAttempts() ||
          ($queue_item->getAttempts() > google_analytics_counter_queue_google_analytics_queue_item_threshold()))) {
      $processed = TRUE;
    }
    if ($queue_item->getProcessedState()) {
      $processed = TRUE;
    } */
    $processed = TRUE;
  }
  while (!$processed);
  // Keep in mind that the queue item might not actually be truly be deleted
  // as some conditions might not be met and therefore, the queue item will be
  // saved instead of deleted.
  $queue_item->delete();
  // Increment the progress and set the message.
  $context['sandbox']['progress']++;
  $context['message'] = t('Process queue item: %path', array('%path' => $queue_item->getPath()));
  return TRUE;
}

/**
 * Redirects the end user to Google Accounts to provide authorization.
 */
function google_analytics_counter_queue_api_auth_obtain_auth(GoogleAnalyticsCounterQueueGoogleApiClient $client) {
  // If the overlay module is enabled, let's close the dialog.
  if (module_exists('overlay') && 'child' == overlay_get_mode()) {
    overlay_close_dialog();
    overlay_deliver_empty_page();
  }
  // Retrieve the consumer token from the API client instance.
  $consumer_token = $client->getConsumer()->key;
  if (empty($consumer_token)) {
    google_analytics_counter_queue_log(WATCHDOG_ALERT, 'Attempting to obtain authorization from Google accounts, however, the consumer oauth key is empty.');
    drupal_set_message(t('An error occurred while attempting to obtain authorization. Please try again.'), 'warning');
    drupal_goto('admin/config/system/google-analytics-counter-queue/authentication');
    return;
  }
  // Redirect the user to the Google Accounts API authorization form. If the
  // user provides access, he or she will be redirected and returned to the
  // oauth callback page at /google-analytics-counter-queue/oauth.
  drupal_goto('https://www.google.com/accounts/OAuthAuthorizeToken', array(
    'query' => array(
      'oauth_token' => $consumer_token,
      'hd' => 'default',
    ),
  ));
}

/**
 * Performs an API request to retrieve the request token.
 *
 * @param GoogleAnalyticsCounterQueueGoogleApiClient $client
 *   The API client instance.
 *
 * @return array
 *   Returns the HTTP response data.
 */
function google_analytics_counter_queue_api_auth_request_token(GoogleAnalyticsCounterQueueGoogleApiClient $client) {
  $parameters = array(
    'scope' => 'https://www.googleapis.com/auth/analytics.readonly',
    'xoauth_displayname' => google_analytics_counter_queue_xoauth_display_name(),
    'oauth_callback' => google_analytics_counter_queue_oauth_callback_url(),
  );
  return google_analytics_counter_queue_api_request($client, 'auth/request-token', $parameters);
}

/**
 * Performs an API request to retrieve the access token.
 *
 * @param GoogleAnalyticsCounterQueueGoogleApiClient $client
 *   The API client instance.
 *
 * @return array
 *   Returns the HTTP response data.
 */
function google_analytics_counter_queue_api_auth_access_token(GoogleAnalyticsCounterQueueGoogleApiClient $client) {
  $parameters = array('oauth_verifier' => $client->getVerifier());
  return google_analytics_counter_queue_api_request($client, 'auth/access-token', $parameters);
}

/**
 * Performs an API request to revoke the access token.
 *
 * @param GoogleAnalyticsCounterQueueGoogleApiClient $client
 *   The API client instance.
 *
 * @return array
 *   Returns the HTTP response data.
 */
function google_analytics_counter_queue_api_auth_revoke(GoogleAnalyticsCounterQueueGoogleApiClient $client) {
  return google_analytics_counter_queue_api_request($client, 'auth/revoke-token');
}

/**
 * Performs an API request to the Google Analytics data endpoint.
 *
 * @param GoogleAnalyticsCounterQueueGoogleApiClient $client
 *   The API client instance.
 * @param mixed $ids
 *   The profile ids to retrieve data from. Default value is NULL, however, the
 *   Google Analytics API endpoint requires this parameter.
 * @param array $dimensions
 *   An array of dimensions to retrieve.
 * @param array $metrics
 *   An array of metrics to retrieve.
 * @param array $filters
 *   An array of filters to apply to the data query.
 * @param string $start_date
 *   The start date in YYYY-MM-DD format for data query filtering.
 * @param string $end_date
 *   The end date in YYYY-MM-DD format for data query filtering.
 * @param int $start_index
 *   The starting index of results to retrieve. Default value is 0.
 * @param int $max_results
 *   The maximum number of results to retrieve.
 *
 * @return array
 *   Returns the HTTP response data.
 *
 * @see https://developers.google.com/analytics/devguides/reporting/core/v3/
 */
function google_analytics_counter_queue_api_request_data(GoogleAnalyticsCounterQueueGoogleApiClient $client, $ids = NULL, array $dimensions = array(), array $metrics = array(), array $filters = array(), $start_date = NULL, $end_date = NULL, $start_index = 0, $max_results = NULL) {
  // TODO: Cleanup and restructure where appropriate.
  $parameters = array(
    'ids' => 'ga:' . $ids,
    'dimensions' => implode(',', $dimensions),
    'metrics' => implode(',', $metrics),
  );

  if ($start_date) {
    $parameters['start-date'] = $start_date;
  }

  if ($end_date) {
    $parameters['end-date'] = $end_date;
  }

  if ($start_index) {
    $parameters['start-index'] = $start_index;
  }

  if ($max_results) {
    $parameters['max-results'] = $max_results;
  }

  if (!empty($filters)) {
    foreach ($filters as $filter_name => $filter_info) {
      foreach ($filter_info as $k => $filter_item) {
        if (is_array($filter_item)) {
          $value = $filter_item['value'];
          $operator = isset($filter_item['operator']) ? $filter_item['operator'] : '==';
        }
        else {
          $value = $filter_item;
          $operator = '==';
        }

        $parameters['filters'][$filter_name][] = array(
          'value' => $value,
          'operator' => $operator,
        );
      }
    }
  }

  return google_analytics_counter_queue_api_request($client, 'analytics/data', $parameters);
}

/**
 * Performs an API request to retrieve Google Analytic Web Properties.
 *
 * Upon a successful HTTP request, should the response be OK (HTTP 200), the
 * data is cached to the key below permanently until caches flushed.
 *   * `google_analytics_counter_queue:api:analytics/web-properties`
 *
 * @param string $account_id
 *   The account id to retrieve web properties for. Default NULL.
 *
 * @return array
 *   Returns the HTTP response data. Returns NULL if the request was not
 *   successful and the `google_analytics_counter_queue_api_request` returned
 *   FALSE.
 */
function google_analytics_counter_queue_api_request_web_properties($account_id = NULL) {
  $cache = cache_get('google_analytics_counter_queue:api:analytics/web-properties');
  if (empty($cache)) {
    $parameters = array();
    if ($account_id) {
      $parameters['@account-id'] = $account_id;
    }

    $client = google_analytics_counter_queue_api_client();
    if ($response = google_analytics_counter_queue_api_request($client, 'analytics/web-properties', $parameters)) {
      if ('200' == $response['code'] && !empty($response['data'])) {
        cache_set('google_analytics_counter_queue:api:analytics/web-properties', $response);
      }
    }
    else {
      $response = NULL;
    }
  }
  else {
    $response = $cache->data;
  }
  return $response;
}

/**
 * Performs an API request to retrieve Google Analytic Profiles.
 *
 * Upon a successful HTTP request, should the response be OK (HTTP 200), the
 * data is cached to the key below permanently until caches flushed.
 *   * `google_analytics_counter_queue:api:analytics/profiles`
 *
 * @param string $account_id
 *   The account id to retrieve the profiles from.
 * @param string $profile_id
 *   The profile id to retrieve the information for specifically. Default NULL.
 *
 * @return array
 *   Returns the HTTP response data. Returns NULL if the request was not
 *   successful and the `google_analytics_counter_queue_api_request` returned
 *   FALSE.
 */
function google_analytics_counter_queue_api_request_profiles($account_id = NULL, $profile_id = NULL) {
  // TODO: Take into account $account_id and $profile_id for caching.
  $cache = cache_get('google_analytics_counter_queue:api:analytics/profiles');
  if (empty($cache)) {
    $parameters = array();
    if ($account_id) {
      $parameters['@account-id'] = $account_id;
    }
    if ($profile_id) {
      $parameters['@profile-id'] = $profile_id;
    }

    $client = google_analytics_counter_queue_api_client();
    if ($response = google_analytics_counter_queue_api_request($client, 'analytics/profiles', $parameters)) {
      if ('200' == $response['code'] && !empty($response['code'])) {
        cache_set('google_analytics_counter_queue:api:analytics/profiles', $response);
      }
    }
    else {
      $response = NULL;
    }
  }
  else {
    $response = $cache->data;
  }

  return $response;
}

/**
 * Performs an HTTP request to the API.
 *
 * @param GoogleAnalyticsCounterQueueGoogleApiClient $client
 *   The client instance.
 * @param string $endpoint_name
 *   The name of the endpoint.
 * @param array $parameters
 *   The request parameters.
 * @param array $headers
 *   An array of HTTP headers.
 * @param int $timeout
 *   The HTTP timeout value. Default is NULL and therefore the configured HTTP
 *   timeout value will be used.
 *
 * @return mixed
 *   Returns the HTTP response data as an array if successful, otherwise FALSE.
 */
function google_analytics_counter_queue_api_request(GoogleAnalyticsCounterQueueGoogleApiClient $client, $endpoint_name, array $parameters = array(), array $headers = array(), $timeout = NULL) {
  $endpoint = google_analytics_counter_queue_api_endpoint_info($endpoint_name);
  // If the endpoint does not exist, log the error and return FALSE.
  if (!$endpoint) {
    google_analytics_counter_queue_log(WATCHDOG_WARNING, 'Attempted to invoke HTTP request using an invalid endpoint (%endpoint).', array('%endpoint' => $endpoint_name));
    return FALSE;
  }

  // Add the name of the endpoint to the endpoint info array.
  $endpoint['name'] = $endpoint_name;
  // Ensure that the $endpoint information contains all default properties.
  $endpoint = $endpoint + _google_analytics_counter_queue_api_endpoint_info_defaults();

  // If the endpoint requires authentication (default value is TRUE), validate
  // that the client is authenticated and should it not be, log the error and
  // return FALSE.
  if ($endpoint['authenticated'] && !$client->isAuthenticated()) {
    google_analytics_counter_queue_log(WATCHDOG_WARNING, 'Attempt t perform Google API request without being authenticated. Endpoint is: %endpoint', array('%endpoint' => $endpoint_name));
    return FALSE;
  }

  // Check if the endpoint's path has specific parameters (e.g. @account-id) and
  // ensure that they are assigned an appropriate value prior to generating
  // the request url.
  if (!empty($endpoint['path_parameters'])) {
    $combined_params = $parameters + $endpoint['path_parameters'];
    $endpoint['path'] = strtr($endpoint['path'], $combined_params);
  }

  // Ensure the endpoint has all default properties to ensure that no HTTP 400
  // Bad Requests occur results as a result of missing parameters.
  $parameters = $parameters + $endpoint['parameters'];
  // Concatenate the endpoint's host and path.
  $request_url = $endpoint['host'] . '/' . $endpoint['path'];

  google_analytics_counter_queue_module_include();

  drupal_alter('google_analytics_counter_queue_api_request', $parameters, $endpoint, $request_url);

  $original_parameters = $parameters;
  $compiled_parameters = _google_analytics_counter_queue_api_request_parameters_compile($original_parameters);

  $request = OAuthRequest::from_consumer_and_token($client->getConsumer(), $client->getToken(), $endpoint['method'], $request_url, $compiled_parameters);
  $request->sign_request($client->getSignatureMethod(), $client->getConsumer(), $client->getToken());

  $http_data = '';
  if (GOOGLE_ANALYTICS_COUNTER_QUEUE_HTTP_POST == $request->get_normalized_http_method()) {
    $url = $request->get_normalized_http_url();
    $http_data = http_build_query($request->get_parameters());
  }
  else {
    $url = $request->to_url();
  }

  if (NULL === $headers) {
    $headers = array();
  }

  $headers = $headers + array();
  $timeout = $timeout ? $timeout : google_analytics_counter_queue_api_http_request_timeout();

  $http_options = array(
    'headers' => $headers,
    'method' => $request->get_normalized_http_method(),
    'timeout' => $timeout,
    'data' => $http_data,
    // Do not allow any redirects to occur, this will ensure that multiple
    // HTTP requests are not happening.
    'max_redirects' => 0,
  );

  $http_response = drupal_http_request($url, $http_options);
  if ('200' == $http_response->code) {
    if ($endpoint['json'] && !empty($http_response->data)) {
      $http_response->data = drupal_json_decode($http_response->data);
    }
  }
  else {
    // If the response is not an HTTP 200, log the response information allowing
    // for further diagnosis if needed. Additionally, normalize the response data
    // property so that all hell doesn't break loose.
    if (!isset($http_response->data)) {
      $http_response->data = '';
    }

    if ('auth/revoke-token' != $endpoint['name']) {
      google_analytics_counter_queue_log(WATCHDOG_ERROR, 'Attempted to perform HTTP request to Google API and received a non-HTTP 200 response. Response Code: %response_code, Response Error: %response_error, Response Status Message: %response_message, Response body: %response_body', array(
        '%response_error' => $http_response->code,
        '%response_error' => !empty($http_response->error) ? $http_response->error : 'No error message',
        '%response_message' => $http_response->status_message,
        '%response_body' => $http_response->data,
        '%response' => $http_response,
      ));
    }
  }

  // If the response is a HTTP 401 Unauthorized, immediately revoke the token.
  if ('401' == $http_response->code && 'Unauthorized' == $http_response->error && 'auth/revoke-token' != $endpoint['name']) {
    global $locks;
    // Directly use $locks and perform an isset() to verify that the lock does
    // not exist. The lock_acquire() function does not perform or creating
    // blocking locks and as a result we will continue to have a recursive loop.
    if (!isset($locks['google_analytics_counter_queue_request_revoke']) && lock_acquire('google_analytics_counter_queue_request_revoke')) {
      $client->revokeToken();
      drupal_set_message(t('Invalid authorization credentials for Google Analytics API resulting in an automatic deauthorization and token revoke.'), 'error');
      lock_release('google_analytics_counter_queue_request_revoke');
    }
  }

  // Convert the response object to an array as some responses may be cached
  // and as a result, cached objects will be converted into an array.
  $http_response = (array) $http_response;
  return $http_response;
}

/**
 * Compiles the API parameters into a single dimension array.
 *
 * @param array $parameters
 *   The original parameters to process.
 *
 * @return array
 *   Returns the "compiled" parameters.
 */
function _google_analytics_counter_queue_api_request_parameters_compile(array $parameters) {
  // TODO: Re-implement so that this isn't such a disaster, but it works for now.
  $compiled = array();
  foreach ($parameters as $param_name => $param_value) {
    if (is_array($param_value)) {
      foreach ($param_value as $key => $value) {
        if (is_array($value)) {
          foreach ($value as $k => $v) {
            if (is_array($v)) {
              if (isset($v['value'])) {
                $val = $v['value'];
                if (isset($v['operator'])) {
                  $op = $v['operator'];
                }
              }
              else {
                continue;
              }
            }
            else {
              $val = $v;
            }

            $op = isset($op) ? $op : '==';
            $compiled[$param_name][] = $key . $op . $val;
          }
        }
        else {
          // TODO: Figure out this case.
        }
      }

      if (!empty($compiled[$param_name])) {
        $compiled[$param_name] = implode(',', $compiled[$param_name]);
      }
    }
    else {
      $compiled[$param_name] = $param_value;
    }
  }
  $compiled = array_filter($compiled);
  return $compiled;
}

/**
 * Retrieves the endpoint information for a single or all endpoints.
 *
 * @param mixed $endpoint
 *   The endpoint identifier if retrieving a single endpoint. Default value is
 *   NULL which in turn will return all endpoints.
 *
 * @return mixed
 *   Returns an array of all endpoints if no endpoint name is specified. Should
 *   an endpoint name be specified and the endpoint exists, the endpoint
 *   information will be returned otherwise FALSE.
 */
function google_analytics_counter_queue_api_endpoint_info($endpoint = NULL) {
  $info = _google_analytics_counter_queue_api_endpoint_info();
  return $endpoint ? (isset($info[$endpoint]) ? $info[$endpoint] : FALSE) : $info;
}

/**
 * Returns an array of all endpoint information.
 *
 * @return array
 *   An associative array of endpoint information.
 */
function _google_analytics_counter_queue_api_endpoint_info() {
  return array(
    'auth/request-token' => array(
      'host' => 'https://www.google.com',
      'path' => 'accounts/OAuthGetRequestToken',
      'authenticated' => FALSE,
      'json' => FALSE,
    ),
    'auth/access-token' => array(
      'host' => 'https://www.google.com',
      'path' => 'accounts/OAuthGetAccessToken',
      'authenticated' => FALSE,
      'json' => FALSE,
    ),
    'auth/revoke-token' => array(
      'host' => 'https://www.google.com',
      'path' => 'accounts/AuthSubRevokeToken',
      'authenticated' => FALSE,
      'json' => FALSE,
    ),
    'analytics/web-properties' => array(
      'path' => 'management/accounts/@account-id/webproperties',
      'path_parameters' => array(
        '@account-id' => '~all',
      ),
    ),
    'analytics/profiles' => array(
      'path' => 'management/accounts/@account-id/webproperties/@webproperty-id/profiles',
      'path_parameters' => array(
        '@account-id' => '~all',
        '@webproperty-id' => '~all',
      ),
    ),
    'analytics/data' => array(
      'path' => 'data/ga',
      'parameters' => array(
        'ids' => array(),
        'dimensions' => array(),
        'filters' => array(),
        'start-date' => google_analytics_counter_queue_api_data_query_start_date(),
        'end-date' => format_date(strtotime('tomorrow'), 'custom', 'Y-m-d'),
        'start-index' => 1,
        'max-results' => google_analytics_counter_queue_api_data_query_max_results(),
      ),
    ),
  );
}

/**
 * Returns an array of default properties for each endpoint.
 *
 * @return array
 *   An array of default properties.
 */
function _google_analytics_counter_queue_api_endpoint_info_defaults() {
  return array(
    'method' => GOOGLE_ANALYTICS_COUNTER_QUEUE_HTTP_GET,
    'host' => 'https://www.googleapis.com/analytics/v3',
    'path' => '',
    'path_parameters' => array(),
    'authenticated' => TRUE,
    'parameters' => array(),
    'json' => TRUE,
  );
}

/**
 * Checks the specified path to determine if it is a valid Drupal path.
 *
 * Note that should an external URL is specified as the `$path`, this function
 * will always return FALSE.
 *
 * @param string $path
 *   The path to validate whether or not it exists.
 *
 * @return boolean
 *   Returns TRUE if the specified path is valid, otherwise FALSE.
 */
function google_analytics_counter_queue_valid_path($path) {
  static $static_fast_cache = array();

  if (!isset($static_fast_cache[$path])) {
    if (!url_is_external($path)) {
      if (FALSE !== ($source = drupal_lookup_path('source', $path))) {
        $static_fast_cache[$path] = TRUE;
      }
      else if (FALSE !== ($alias = drupal_lookup_path('alias', $path))) {
        $static_fast_cache[$path] = TRUE;
      }
      else {
        if (FALSE !== ($router_item = menu_get_item($path))) {
          $static_fast_cache[$path] = TRUE;
        }
      }
    }
  }

  if (!isset($static_fast_cache[$path])) {
    $static_fast_cache[$path] = FALSE;
  }

  return $static_fast_cache[$path];
}

/**
 * Returns an array of valid select options for positioning of queue item.
 *
 * @return array
 *   The queue item position options.
 */
function google_analytics_counter_queue_queue_item_form_position_options() {
  return array(
    'bottom' => t('Default (bottom of queue)'),
    'top' => t('Top of queue'),
  );
}

/**
 * Returns the node identifier should the path be a node viewing path.
 *
 * Note: This function returns FALSE for all node action or local task paths
 * such as node/[nid]/edit.
 *
 * Furthermore, a node alias may be specified as $path which will perform a path
 * normalization allowing for the node system path to be retrieved and parsed.
 *
 * @param string $path
 *   The path to attempt to retrieve the node id for.
 *
 * @return mixed
 *   Returns the node id as an integer, otherwise FALSE.
 */
function google_analytics_counter_queue_path_is_node_view($path) {
  $path = drupal_get_normal_path($path);
  if (preg_match('|node/([0-9]+)?|', $path, $matches)) {
    return isset($matches[1]) && is_numeric($matches[1]) ? intval($matches[1]) : FALSE;
  }
  return FALSE;
}

if (!function_exists('node_google_analytics_counter_queue_api')) {
  /**
   * Implements hook_google_analytics_counter_queue_api().
   */
  function node_google_analytics_counter_queue_api() {
    return google_analytics_counter_queue_google_analytics_counter_queue_api();
  }
}

if (!function_exists('statistics_google_analytics_counter_queue_api')) {
  /**
   * Implements hook_google_analytics_counter_queue_api().
   */
  function statistics_google_analytics_counter_queue_api() {
    return google_analytics_counter_queue_google_analytics_counter_queue_api();
  }
}

if (!function_exists('rules_google_analytics_counter_queue_api')) {
  /**
   * Implements hook_google_analytics_counter_queue_api().
   */
  function rules_google_analytics_counter_queue_api() {
    return google_analytics_counter_queue_google_analytics_counter_queue_api();
  }
}
